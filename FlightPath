#!/usr/bin/env python3
import os
import math
import webbrowser

import rclpy
import pandas as pd
import folium
from geographiclib.geodesic import Geodesic
from rclpy.node import Node
from px4_msgs.msg import VehicleOdometry
from rclpy.qos import QoSProfile, QoSReliabilityPolicy, QoSHistoryPolicy

class FlightPathPost(Node):
    def __init__(self):
        super().__init__('flight_path_post')

        # static home GPS position (latitude, longitude)
        self.home_lat = 52.0100  # replace with your take-off lat
        self.home_lon = 4.3600   # replace with your take-off lon

        # parameter for output directory
        self.declare_parameter('output_dir', '/tmp')
        out_dir = self.get_parameter('output_dir').value

        os.makedirs(out_dir, exist_ok=True)
        self.csv_path = os.path.join(out_dir, 'flight_odometry.csv')
        self.html_path = os.path.join(out_dir, 'flight_path.html')

        # storage buffers
        self.times = []
        self.xs = []
        self.ys = []
        self.zs = []

        # configure QoS to match PX4 publisher (best effort reliability)
        qos = QoSProfile(
            reliability=QoSReliabilityPolicy.BEST_EFFORT,
            history=QoSHistoryPolicy.KEEP_LAST,
            depth=10
        )

        # subscription to PX4 odometry with compatible QoS
        self.create_subscription(
            VehicleOdometry,
            '/fmu/out/vehicle_odometry',
            self.odom_cb,
            qos
        )

        # geodetic converter
        self.geod = Geodesic.WGS84

        self.get_logger().info(
            f"Logging to {self.csv_path}\nHome pos = ({self.home_lat}, {self.home_lon})"
        )

    def odom_cb(self, msg: VehicleOdometry):
        # filter to NED frame
        if msg.pose_frame != VehicleOdometry.POSE_FRAME_NED:
            return
        # filter out invalid data
        if any(math.isnan(v) for v in msg.position):
            return

        # timestamp in seconds (from microseconds)
        t = msg.timestamp * 1e-6
        # position in meters: [north, east, down/up]
        x, y, z = msg.position

        self.times.append(t)
        self.xs.append(x)
        self.ys.append(y)
        self.zs.append(z)

    def save_csv(self):
        df = pd.DataFrame({
            'timestamp_s': self.times,
            'x_m': self.xs,
            'y_m': self.ys,
            'z_m': self.zs,
        })
        df.to_csv(self.csv_path, index=False)
        self.get_logger().info(f"Saved CSV → {self.csv_path}")
        return df

    def make_map(self, df: pd.DataFrame):
        # convert NED offsets (north=x, east=y) into geodetic lat/lon
        lats, lons = [], []
        for north, east in zip(df.x_m, df.y_m):
            az = math.degrees(math.atan2(east, north))
            dist = math.hypot(north, east)
            g = self.geod.Direct(self.home_lat, self.home_lon, az, dist)
            lats.append(g['lat2'])
            lons.append(g['lon2'])

        # create and save interactive map
        m = folium.Map(location=[lats[0], lons[0]], zoom_start=17)
        folium.PolyLine(list(zip(lats, lons)), weight=4).add_to(m)
        folium.Marker([lats[0], lons[0]], popup="Launch").add_to(m)
        folium.Marker([lats[-1], lons[-1]], popup="Landing").add_to(m)
        m.save(self.html_path)
        self.get_logger().info(f"Saved map → {self.html_path}")

        # open in default browser window
        webbrowser.open('file://' + os.path.abspath(self.html_path))

    def on_shutdown(self):
        df = self.save_csv()
        if not df.empty:
            self.make_map(df)
        else:
            self.get_logger().warn("No data recorded; skipping map generation.")


def main(args=None):
    rclpy.init(args=args)
    node = FlightPathPost()
    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        node.get_logger().info("Shutdown requested, processing data…")
    finally:
        node.on_shutdown()
        node.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
