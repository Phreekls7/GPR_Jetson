#!/usr/bin/env python3
import sys
import threading
import math
import socket
import binascii
import gc
import rclpy
from rclpy.node import Node
from rclpy.executors import SingleThreadedExecutor

# Messages
from px4_msgs.msg import VehicleOdometry
from sensor_msgs.msg import Range
from cv_bridge import CvBridge

# Qt
from PyQt5.QtWidgets import QApplication, QMainWindow, QWidget, QVBoxLayout, QLabel
from PyQt5.QtCore import QTimer, Qt
import pyqtgraph as pg
import numpy as np

# GPR Protocol Constants
ACK_HEX = b'007f007f'

class TelemetryGUI(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle('Drone Telemetry')

        # ROS2 Init
        rclpy.init()
        self.node = Node('telemetry_gui')
        self.executor = SingleThreadedExecutor()
        self.executor.add_node(self.node)
        threading.Thread(target=self.executor.spin, daemon=True).start()

        # Bridge
        self.bridge = CvBridge()

        # Flight Path Data
        self.path = []
        self.origin = None

        # Laser Range
        self.latest_range = 0.0
        self.node.create_subscription(Range,
                                      '/range',
                                      self.range_cb,
                                      QoSProfile(depth=10))

        # GPR Settings
        self.host = '192.168.0.10'
        self.port = 23
        self.quantity = 1024
        self.gpr_range = 100
        self.window_cols = 1000
        self.pix_per_m = 20

        # Preallocate buffers
        svc = self.quantity // 16
        self.n_samples = self.quantity - svc
        self.data = np.zeros((self.n_samples, self.window_cols), dtype=np.int16)
        self.range_hist = [0.0]*self.window_cols
        self.filled = 0
        self.latest_img = None
        self.stop_evt = threading.Event()

        # Start GPR reader thread
        self._connect_gpr()
        threading.Thread(target=self._reader_loop, daemon=True).start()

        # Build UI
        central = QWidget()
        self.setCentralWidget(central)
        layout = QVBoxLayout(central)

        # Flight Path plot
        self.plot = pg.PlotWidget(title='Flight Path')
        self.plot.setBackground('w')
        self.plot.showGrid(True, True)
        self.path_curve = self.plot.plot([], [], pen='b')
        layout.addWidget(self.plot)

        # Range Label
        self.range_label = QLabel('Range: -- m')
        self.range_label.setAlignment(Qt.AlignCenter)
        layout.addWidget(self.range_label)

        # GPR ImageView
        self.img_view = pg.ImageView()
        for btn in (self.img_view.ui.histogram,
                    self.img_view.ui.roiBtn,
                    self.img_view.ui.menuBtn):
            btn.hide()
        view = self.img_view.getView()
        view.enableAutoRange(False)
        view.setAspectLocked(False)
        layout.addWidget(self.img_view)

        # UI Timer
        self.timer = QTimer()
        self.timer.timeout.connect(self.update_ui)
        self.timer.start(33)

    def _connect_gpr(self):
        msg = self._setup_msg(self.quantity, self.gpr_range) + '\n'
        self.sock = socket.create_connection((self.host, self.port), timeout=5)
        self.sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
        gc.disable()
        self.sock.sendall(msg.encode())
        self.sock.sendall(b'P1\n')
        ack = self.sock.recv(4)
        if binascii.hexlify(ack) != ACK_HEX:
            raise RuntimeError('Bad ACK from GPR')
        self.sock.recv(1)

    def _setup_msg(self, q, rng):
        # bit‚Äêbuild like original
        m_N, m_00, m_01 = ' ', '1', '1'
        m_07, m_08_10, m_11_12, m_15 = '0','000','00','0'
        m_16_19, m_20_21, m_22_31 = '1010','00','1010110010'
        if q==128: m_05_06='00'
        elif q==256: m_05_06='10'
        elif q==512: m_05_06='01'
        elif q==1024: m_05_06='11'
        else: m_05_06='01'
        if rng==25: m_02_04,m_13_14='000','10'
        elif rng==50: m_02_04,m_13_14='000','00'
        elif rng==100: m_02_04,m_13_14='100','00'
        elif rng==200: m_02_04,m_13_14='010','00'
        elif rng==300: m_02_04,m_13_14='110','00'
        elif rng==2000: m_02_04,m_13_14='111','00'
        else: m_02_04,m_13_14='000','00'
        return ('T'+m_N+m_00+m_01+m_02_04+m_05_06+m_07 +
                m_08_10+m_11_12+m_13_14+m_15+m_16_19+m_20_21+m_22_31)

    def _reader_loop(self):
        while not self.stop_evt.is_set():
            # read raw buffer
            buf = b''
            needed = self.quantity*2
            while len(buf) < needed:
                chunk = self.sock.recv(needed-len(buf))
                if not chunk: return
                buf += chunk
            trace = np.frombuffer(buf[:self.n_samples*2], dtype='>i2')
            # roll data
            if self.filled < self.window_cols:
                self.data[:,self.filled] = trace
                self.range_hist[self.filled] = self.latest_range
                self.filled += 1
            else:
                np.roll(self.data, -1, axis=1, out=self.data)
                self.data[:,-1] = trace
                self.range_hist.pop(0)
                self.range_hist.append(self.latest_range)
            # convert to uint8
            img = ((self.data.astype(np.int32)+32768) * (255.0/65535.0)).astype(np.uint8)
            # apply per-column offset
            adj = np.zeros_like(img)
            for j in range(img.shape[1]):
                off = int(self.range_hist[j] * self.pix_per_m)
                adj[:,j] = np.roll(img[:,j], -off, axis=0)
            self.latest_img = adj

    def range_cb(self, msg: Range):
        self.latest_range = msg.range

    def odom_cb(self, msg: VehicleOdometry):
        if msg.pose_frame == VehicleOdometry.POSE_FRAME_FRD:
            x,y,_ = msg.position
        else:
            xn,yn,_ = msg.position; x,y = yn,xn
        if self.origin is None:
            self.origin = (x,y)
        xr,yr = x-self.origin[0], y-self.origin[1]
        w,xq,yq,zq = msg.q
        yaw = math.atan2(2*(w*zq+xq*yq),1-2*(yq*yq+zq*zq))
        c,s = math.cos(-yaw), math.sin(-yaw)
        self.path.append((xr*c-yr*s, xr*s+yr*c))

    def update_ui(self):
        # plot flight path
        if self.path:
            xs,ys = zip(*self.path)
            self.plot.clear(); self.plot.addItem(self.path_curve)
            self.path_curve.setData(xs,ys)
        # update range
        self.range_label.setText(f'Range: {self.latest_range:.2f} m')
        # show GPR
        if self.latest_img is not None:
            disp = self.latest_img.T
            self.img_view.setImage(disp, autoLevels=True)
            h,w = disp.shape
            v = self.img_view.getView()
            v.setRange(xRange=(0,w), yRange=(0,h), padding=0)

    def closeEvent(self, event):
        self.stop_evt.set()
        try: self.sock.close()
        except: pass
        self.executor.shutdown()
        self.node.destroy_node()
        rclpy.shutdown()
        event.accept()

if __name__=='__main__':
    app = QApplication(sys.argv)
    gui = TelemetryGUI()
    gui.showMaximized()
    sys.exit(app.exec_())
