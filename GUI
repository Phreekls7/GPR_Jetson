import sys
import threading
import math
import rclpy
from rclpy.node import Node
from rclpy.executors import SingleThreadedExecutor

# Messages
from px4_msgs.msg import VehicleOdometry  # REP147-compatible vehicle odometry
from sensor_msgs.msg import Image, Range
from cv_bridge import CvBridge

# QoS for PX4 topics
from rclpy.qos import QoSProfile, QoSReliabilityPolicy, QoSDurabilityPolicy

from PyQt5.QtWidgets import QApplication, QMainWindow, QWidget, QVBoxLayout, QLabel, QHBoxLayout
from PyQt5.QtCore import QTimer, Qt
import pyqtgraph as pg
import numpy as np

class TelemetryGUI(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle('Drone Telemetry')

        # --- ROS2 init, node, and executor in background thread ---
        rclpy.init(args=None)
        self.node = Node('telemetry_gui')
        self.executor = SingleThreadedExecutor()
        self.executor.add_node(self.node)
        self.spin_thread = threading.Thread(target=self.executor.spin, daemon=True)
        self.spin_thread.start()

        # --- Subscribers (with matching QoS) ---
        self.bridge = CvBridge()
        self.node.create_subscription(Image, '/gpr/bscan', self.gpr_cb, qos_profile=10)
        self.node.create_subscription(Range, '/range', self.range_cb, qos_profile=10)
        odom_qos = QoSProfile(depth=10)
        odom_qos.reliability = QoSReliabilityPolicy.BEST_EFFORT
        odom_qos.durability = QoSDurabilityPolicy.VOLATILE
        self.node.create_subscription(
            VehicleOdometry,
            '/fmu/out/vehicle_odometry',
            self.odom_cb,
            qos_profile=odom_qos
        )

        # --- Data containers ---
        self.path = []           # list of (x, y)
        self.origin = None       # for centering path
        self.latest_gpr = None   # numpy array for GPR image
        self.latest_range = None # float for range

        # --- Build UI ---
        central = QWidget()
        self.setCentralWidget(central)
        layout = QVBoxLayout(central)

        # Top layout: flight path + range display (half screen)
        top = QHBoxLayout()
        self.plot_widget = pg.PlotWidget(title="Flight Path")
        self.plot_widget.setAspectLocked(True)
        self.plot_widget.enableAutoRange()
        self.path_curve = self.plot_widget.plot([], [], pen=pg.mkPen(width=2))
        top.addWidget(self.plot_widget, stretch=3)

        self.range_label = QLabel("Range: -- m")
        self.range_label.setAlignment(Qt.AlignCenter)
        self.range_label.setFixedWidth(150)
        top.addWidget(self.range_label, stretch=1)
        layout.addLayout(top, stretch=1)

        # Bottom layout: GPR B-scan image (half screen)
        self.img_view = pg.ImageView(view=pg.PlotItem())
        self.img_view.ui.histogram.hide()
        self.img_view.ui.roiBtn.hide()
        self.img_view.ui.menuBtn.hide()
        layout.addWidget(self.img_view, stretch=1)

        # Freeze image view to full history
        iv = self.img_view.getView()
        iv.enableAutoRange(False)
        iv.setAspectLocked(False)

        # --- Timer for UI updates ---
        self.ui_timer = QTimer()
        self.ui_timer.timeout.connect(self.update_ui)
        self.ui_timer.start(30)  # ms (~33 Hz)

    def gpr_cb(self, msg: Image):
        """Handle incoming GPR B-scan Image."""
        self.latest_gpr = self.bridge.imgmsg_to_cv2(msg, desired_encoding='mono8')

    def odom_cb(self, msg: VehicleOdometry):
        """Handle VehicleOdometry: convert frame, center, and rotate by yaw."""
        # Choose frame
        if msg.pose_frame == VehicleOdometry.POSE_FRAME_FRD:
            x, y, _ = msg.position
        else:
            x_ned, y_ned, _ = msg.position
            x = y_ned
            y = x_ned

        # Initialize origin
        if self.origin is None:
            self.origin = (x, y)
        x_rel = x - self.origin[0]
        y_rel = y - self.origin[1]

        # Extract yaw from quaternion
        w, xq, yq, zq = msg.q
        yaw = math.atan2(2*(w*zq + xq*yq), 1 - 2*(yq*yq + zq*zq))

        # Rotate point to align heading
        c, s = math.cos(-yaw), math.sin(-yaw)
        x_rot = x_rel*c - y_rel*s
        y_rot = x_rel*s + y_rel*c

        self.path.append((x_rot, y_rot))
        self.node.get_logger().debug(
            f"[GUI] odom_cb → rel=({x_rel:.2f},{y_rel:.2f}), yaw={math.degrees(yaw):.1f}°"
        )

    def range_cb(self, msg: Range):
        """Handle incoming Range."""
        self.latest_range = msg.range

    def update_ui(self):
        """Update flight path, range label, and full-width GPR image."""
        # Flight path
        if self.path:
            xs, ys = zip(*self.path)
            self.path_curve.setData(xs, ys)

        # Laser range
        if self.latest_range is not None:
            self.range_label.setText(f"Range: {self.latest_range:.2f} m")

        # GPR image
        if self.latest_gpr is not None:
            img = self.latest_gpr.T
            self.img_view.setImage(img, autoLevels=True)
            # Lock view
            h, w = img.shape
            v = self.img_view.getView()
            v.setRange(xRange=(0, w), yRange=(0, h), padding=0)

    def closeEvent(self, event):
        """Clean up ROS and threads on close."""
        self.executor.shutdown()
        self.spin_thread.join(timeout=1.0)
        self.node.destroy_node()
        rclpy.shutdown()
        event.accept()

if __name__ == '__main__':
    app = QApplication(sys.argv)
    gui = TelemetryGUI()
    gui.showMaximized()
    sys.exit(app.exec_())
