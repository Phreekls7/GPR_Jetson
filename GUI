import sys
import threading
import math
import queue
import gc
import rclpy
from rclpy.node import Node
from rclpy.executors import SingleThreadedExecutor

# Messages
from px4_msgs.msg import VehicleOdometry
from sensor_msgs.msg import Image, Range
from cv_bridge import CvBridge

# QoS
from rclpy.qos import QoSProfile, QoSReliabilityPolicy, QoSDurabilityPolicy

# Qt
from PyQt5.QtWidgets import QApplication, QMainWindow

# OpenCV
import cv2

# Other
import numpy as np
import requests
import pyproj

class TelemetryGUI(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle('Drone Telemetry')

        # ROS2 init
        rclpy.init(args=None)
        self.node = Node('telemetry_gui')
        self.executor = SingleThreadedExecutor()
        self.executor.add_node(self.node)
        self.spin_thread = threading.Thread(target=self.executor.spin, daemon=True)
        self.spin_thread.start()

        # Bridge for images
        self.bridge = CvBridge()

        # Queue for OpenCV display
        self.img_q = queue.Queue(maxsize=10)
        self.stop_evt = threading.Event()
        threading.Thread(target=self._gpr_display_loop, daemon=True).start()

        # Subscriptions
        qos = QoSProfile(depth=10)
        qos.reliability = QoSReliabilityPolicy.BEST_EFFORT
        qos.durability = QoSDurabilityPolicy.VOLATILE
        self.node.create_subscription(Image, '/gpr/bscan', self.gpr_cb, qos_profile=qos)
        self.node.create_subscription(Range, '/range', self.range_cb, qos_profile=10)
        self.node.create_subscription(VehicleOdometry,
                                      '/fmu/out/vehicle_odometry',
                                      self.odom_cb,
                                      qos_profile=qos)

        # Data containers
        self.path = []
        self.origin = None
        self.latest_range = None

        # Map setup omitted for brevity...

    def gpr_cb(self, msg: Image):
        """Handle incoming GPR B-scan via ROS, enqueue for OpenCV."""
        frame = self.bridge.imgmsg_to_cv2(msg, 'mono8')
        # Transpose so columns match as image
        img = frame.T
        try:
            self.img_q.put_nowait(img)
        except queue.Full:
            pass

    def _gpr_display_loop(self):
        """OpenCV window loop for rolling GPR display."""
        # Setup window
        cv2.namedWindow("GPR B-scan", cv2.WINDOW_NORMAL)
        cv2.resizeWindow("GPR B-scan", 800, 600)
        history = None
        while not self.stop_evt.is_set():
            try:
                img = self.img_q.get(timeout=0.1)
                h, w = img.shape
                if history is None:
                    # Initialize history buffer width = 800
                    history = np.zeros((h, 800), dtype=np.uint8)
                # shift left, append new column (resize input if width >1)
                col = img[:, -1] if img.shape[1] > 1 else img[:, 0]
                history = np.roll(history, -1, axis=1)
                history[:, -1] = col
                cv2.imshow("GPR B-scan", history)
            except queue.Empty:
                cv2.waitKey(1)
            if cv2.waitKey(1) == 27:
                self.stop_evt.set()
                break
        cv2.destroyAllWindows()
        gc.enable()

    def odom_cb(self, msg: VehicleOdometry):
        """Handle VehicleOdometry."""
        # Existing odometry logic unchanged
        if msg.pose_frame == VehicleOdometry.POSE_FRAME_FRD:
            x, y, _ = msg.position
        else:
            xn, yn, _ = msg.position; x, y = yn, xn
        if self.origin is None:
            self.origin = (x, y)
        xr, yr = x - self.origin[0], y - self.origin[1]
        w, xq, yq, zq = msg.q
        yaw = math.atan2(2*(w*zq + xq*yq), 1 - 2*(yq*yq + zq*zq))
        c, s = math.cos(-yaw), math.sin(-yaw)
        xr2 = xr*c - yr*s; yr2 = xr*s + yr*c
        self.path.append((xr2, yr2))

    def range_cb(self, msg: Range):
        """Handle Range message."""
        self.latest_range = msg.range

    def closeEvent(self, event):
        """Cleanup on close."""
        self.stop_evt.set()
        self.executor.shutdown()
        self.spin_thread.join(timeout=1.0)
        self.node.destroy_node()
        rclpy.shutdown()
        event.accept()

if __name__ == '__main__':
    app = QApplication(sys.argv)
    gui = TelemetryGUI()
    gui.show()
    sys.exit(app.exec_())
