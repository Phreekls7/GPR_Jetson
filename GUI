import sys
import threading
import math
import rclpy
from rclpy.node import Node
from rclpy.executors import SingleThreadedExecutor

# Messages
from px4_msgs.msg import VehicleOdometry
from sensor_msgs.msg import Image, Range
from cv_bridge import CvBridge

# QoS
from rclpy.qos import QoSProfile, QoSReliabilityPolicy, QoSDurabilityPolicy

# Qt
from PyQt5.QtWidgets import QApplication, QMainWindow, QWidget, QVBoxLayout, QLabel, QHBoxLayout
from PyQt5.QtCore import QTimer, Qt
import pyqtgraph as pg
import numpy as np
import cv2  # for decoding map images

# Map and projection
import requests
import pyproj

class TelemetryGUI(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle('Drone Telemetry')

        # ROS2 init
        rclpy.init(args=None)
        self.node = Node('telemetry_gui')
        self.executor = SingleThreadedExecutor()
        self.executor.add_node(self.node)
        self.spin_thread = threading.Thread(target=self.executor.spin, daemon=True)
        self.spin_thread.start()

        # Bridge for images
        self.bridge = CvBridge()

        # Subscriptions
        self.node.create_subscription(Image, '/gpr/bscan', self.gpr_cb, qos_profile=10)
        self.node.create_subscription(Range, '/range', self.range_cb, qos_profile=10)
        odom_qos = QoSProfile(depth=10)
        odom_qos.reliability = QoSReliabilityPolicy.BEST_EFFORT
        odom_qos.durability = QoSDurabilityPolicy.VOLATILE
        self.node.create_subscription(VehicleOdometry,
                                      '/fmu/out/vehicle_odometry',
                                      self.odom_cb,
                                      qos_profile=odom_qos)

        # Data containers
        self.path = []
        self.origin = None
        self.latest_range = None

        # GPR history buffer
        self.gpr_history = None          # Will hold rolling buffer
        self.max_history = 800           # Max columns to display/history length

        # Map background setup
        self.map_item = pg.ImageItem()
        self.map_ready = False
        # Geographic origin (set your takeoff coords here)
        self.orig_lat = 37.123456
        self.orig_lon = -122.123456
        # Projection: local ENU (meters) -> lat/lon
        utm_zone = int((self.orig_lon + 180) / 6) + 1
        proj_str = f'+proj=utm +zone={utm_zone} +datum=WGS84'
        self.proj = pyproj.Transformer.from_crs(proj_str, 'EPSG:4326', always_xy=True)

        # Build UI
        central = QWidget()
        self.setCentralWidget(central)
        layout = QVBoxLayout(central)

        # Top: flight path + range
        top = QHBoxLayout()
        self.plot = pg.PlotWidget(title='Flight Path')
        self.plot.setAspectLocked(True)
        self.plot.enableAutoRange()
        self.plot.addItem(self.map_item)
        self.map_item.setZValue(-100)
        self.path_curve = self.plot.plot([], [], pen=pg.mkPen(width=2, color='w'))
        top.addWidget(self.plot, stretch=3)
        self.range_label = QLabel('Range: -- m')
        self.range_label.setAlignment(Qt.AlignCenter)
        self.range_label.setFixedWidth(150)
        top.addWidget(self.range_label, stretch=1)
        layout.addLayout(top, stretch=1)

        # Bottom: GPR B-scan history
        self.img_view = pg.ImageView(view=pg.PlotItem())
        for btn in (self.img_view.ui.histogram, self.img_view.ui.roiBtn, self.img_view.ui.menuBtn):
            btn.hide()
        view = self.img_view.getView()
        view.enableAutoRange(False)
        view.setAspectLocked(False)
        layout.addWidget(self.img_view, stretch=1)

        # Timer for updates
        self.timer = QTimer()
        self.timer.timeout.connect(self.update_ui)
        self.timer.start(30)

    def gpr_cb(self, msg: Image):
        """Handle incoming GPR B-scan Image and update rolling buffer."""
        frame = self.bridge.imgmsg_to_cv2(msg, 'mono8')
        h, w = frame.shape
        # Initialize history buffer on first message
        if self.gpr_history is None:
            # Buffer dimensions: height x max_history
            self.gpr_history = np.zeros((h, self.max_history), dtype=np.uint8)
        # Extract single column of new data
        if w > 1:
            # Downsample horizontally to one column
            col = cv2.resize(frame, (1, h), interpolation=cv2.INTER_AREA)[:, 0]
        else:
            col = frame[:, 0]
        # Roll buffer left by one and insert new column at end
        self.gpr_history = np.roll(self.gpr_history, -1, axis=1)
        self.gpr_history[:, -1] = col

    def odom_cb(self, msg: VehicleOdometry):
        """Handle VehicleOdometry: frame choice, centering, and yaw rotation."""
        if msg.pose_frame == VehicleOdometry.POSE_FRAME_FRD:
            x, y, _ = msg.position
        else:
            xn, yn, _ = msg.position
            x, y = yn, xn
        if self.origin is None:
            self.origin = (x, y)
        xr, yr = x - self.origin[0], y - self.origin[1]
        w, xq, yq, zq = msg.q
        yaw = math.atan2(2*(w*zq + xq*yq), 1 - 2*(yq*yq + zq*zq))
        c, s = math.cos(-yaw), math.sin(-yaw)
        xr2 = xr*c - yr*s
        yr2 = xr*s + yr*c
        self.path.append((xr2, yr2))

    def range_cb(self, msg: Range):
        """Handle incoming Range message."""
        self.latest_range = msg.range

    def update_map_background(self):
        """Fetch and display satellite map covering current path extents."""
        xs, ys = zip(*self.path)
        buf = 10.0
        min_x, max_x = min(xs) - buf, max(xs) + buf
        min_y, max_y = min(ys) - buf, max(ys) + buf
        ll_lon, ll_lat = self.proj.transform(min_x, min_y)
        ur_lon, ur_lat = self.proj.transform(max_x, max_y)
        # Google Maps URL (with API key placeholder)
        url_google = (
            'https://maps.googleapis.com/maps/api/staticmap'
            f'?size=800x800&maptype=satellite&visible={ll_lat},{ll_lon}|{ur_lat},{ur_lon}'
            '&key=YOUR_API_KEY'
        )
        # Fallback: OSM Static Map
        center_lat = (ll_lat + ur_lat) / 2
        center_lon = (ll_lon + ur_lon) / 2
        zoom = 16
        url_osm = (
            'https://staticmap.openstreetmap.de/staticmap.php'
            f'?center={center_lat},{center_lon}'
            f'&zoom={zoom}&size=800x800'
        )
        for url in (url_google, url_osm):
            try:
                resp = requests.get(url, timeout=10)
                if resp.status_code == 200:
                    break
            except Exception:
                continue
        else:
            self.node.get_logger().error(f"Map fetch failed on both services: HTTP {[resp.status_code if 'resp' in locals() else 'n/a']}")
            return
        buf_img = np.frombuffer(resp.content, dtype=np.uint8)
        cv_img = cv2.imdecode(buf_img, cv2.IMREAD_COLOR)
        if cv_img is None:
            self.node.get_logger().error("Failed to decode map image")
            return
        arr = cv2.cvtColor(cv_img, cv2.COLOR_BGR2RGB)
        self.map_item.setImage(arr)
        self.map_item.setRect(min_x, min_y, max_x - min_x, max_y - min_y)
        self.map_ready = True

    def update_ui(self):
        """Update map background (once), flight path, range label, and GPR history view."""
        if not self.map_ready and len(self.path) > 1:
            self.update_map_background()
        if self.path:
            xs, ys = zip(*self.path)
            self.path_curve.setData(xs, ys)
        if self.latest_range is not None:
            self.range_label.setText(f'Range: {self.latest_range:.2f} m')
        # Display rolling GPR history
        if self.gpr_history is not None:
            img = self.gpr_history.T
            self.img_view.setImage(img, autoLevels=True)
            h, w = img.shape
            v = self.img_view.getView()
            v.setRange(xRange=(0, w), yRange=(0, h), padding=0)

    def closeEvent(self, event):
        """Cleanup ROS and threads on window close."""
        self.executor.shutdown()
        self.spin_thread.join(timeout=1.0)
        self.node.destroy_node()
        rclpy.shutdown()
        event.accept()

if __name__ == '__main__':
    app = QApplication(sys.argv)
    gui = TelemetryGUI()
    gui.showMaximized()
    sys.exit(app.exec_())
