#!/usr/bin/env python3
import sys
import threading
import math
import rclpy
from rclpy.node import Node
from rclpy.executors import SingleThreadedExecutor
from rclpy.qos import QoSProfile, QoSReliabilityPolicy, QoSDurabilityPolicy
from px4_msgs.msg import VehicleOdometry
from sensor_msgs.msg import Image, Range
from cv_bridge import CvBridge

from PyQt5.QtWidgets import QApplication, QMainWindow, QWidget, QVBoxLayout, QLabel, QHBoxLayout
from PyQt5.QtCore import QTimer, Qt
import pyqtgraph as pg
import numpy as np
import cv2
import requests
import pyproj

class TelemetryGUI(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle('Drone Telemetry')

        # --- ROS2 initialization ---
        rclpy.init(args=None)
        self.node = Node('telemetry_gui')
        self.executor = SingleThreadedExecutor()
        self.executor.add_node(self.node)
        self.spin_thread = threading.Thread(target=self.executor.spin, daemon=True)
        self.spin_thread.start()
        self.bridge = CvBridge()

                # --- Internal state ---
        self.path = []
        self.origin = None
        self.latest_range = None
        self.latest_gpr = None

        # --- ROS2 Subscriptions ---
        self.path = []
        self.origin = None
        self.latest_range = None
        self.latest_gpr = None

        # --- Map background setup ---
        self.map_item = pg.ImageItem()
        self.map_ready = False
        self.orig_lat = 37.123456  # set your takeoff latitude
        self.orig_lon = -122.123456  # set your takeoff longitude
        utm_zone = int((self.orig_lon + 180) / 6) + 1
        proj_str = f'+proj=utm +zone={utm_zone} +datum=WGS84'
        self.proj = pyproj.Transformer.from_crs(proj_str, 'EPSG:4326', always_xy=True)

        # --- Build UI ---
        central = QWidget()
        self.setCentralWidget(central)
        layout = QVBoxLayout(central)

        # Top: flight path + range display
        top = QHBoxLayout()
        self.plot = pg.PlotWidget(title='Flight Path')
        self.plot.setAspectLocked(True)
        self.plot.enableAutoRange()
        self.plot.addItem(self.map_item)
        self.map_item.setZValue(-100)
        self.path_curve = self.plot.plot([], [], pen=pg.mkPen(width=2, color='w'))
        top.addWidget(self.plot, stretch=3)

        self.range_label = QLabel('Range: -- m')
        self.range_label.setAlignment(Qt.AlignCenter)
        self.range_label.setFixedWidth(150)
        top.addWidget(self.range_label, stretch=1)

        layout.addLayout(top, stretch=1)

        # Bottom: GPR B-scan view
        self.img_view = pg.ImageView(view=pg.PlotItem())
        for btn in (self.img_view.ui.histogram, self.img_view.ui.roiBtn, self.img_view.ui.menuBtn):
            btn.hide()
        iv = self.img_view.getView()
        iv.enableAutoRange(False)
        iv.setAspectLocked(False)
        layout.addWidget(self.img_view, stretch=1)

        # --- UI update timer ---
        self.timer = QTimer()
        self.timer.timeout.connect(self.update_ui)
        self.timer.start(30)  # ~33 Hz

    def gpr_cb(self, msg: Image):
        """Handle incoming GPR B-scan Image."""
        self.latest_gpr = self.bridge.imgmsg_to_cv2(msg, 'mono8')

    def odom_cb(self, msg: VehicleOdometry):
        """Handle VehicleOdometry: frame choice, centering, and yaw rotation."""
        if msg.pose_frame == VehicleOdometry.POSE_FRAME_FRD:
            x, y, _ = msg.position
        else:
            xn, yn, _ = msg.position
            x, y = yn, xn

        if self.origin is None:
            self.origin = (x, y)
        xr, yr = x - self.origin[0], y - self.origin[1]

        w, xq, yq, zq = msg.q
        yaw = math.atan2(2 * (w*zq + xq*yq), 1 - 2 * (yq*yq + zq*zq))
        c, s = math.cos(-yaw), math.sin(-yaw)
        xr2 = xr * c - yr * s
        yr2 = xr * s + yr * c

        self.path.append((xr2, yr2))

    def range_cb(self, msg: Range):
        """Handle incoming Range message."""
        self.latest_range = msg.range

    def update_map_background(self):
        """Fetch and display a simple OSM map covering current path extents."""
        xs, ys = zip(*self.path)
        buf = 10.0
        min_x, max_x = min(xs) - buf, max(xs) + buf
        min_y, max_y = min(ys) - buf, max(ys) + buf

        ll_lon, ll_lat = self.proj.transform(min_x, min_y)
        ur_lon, ur_lat = self.proj.transform(max_x, max_y)

        center_lat = (ll_lat + ur_lat) / 2
        center_lon = (ll_lon + ur_lon) / 2
        zoom = 16

        url = (
            'https://staticmap.openstreetmap.de/staticmap.php'
            f'?center={center_lat},{center_lon}&zoom={zoom}&size=800x800'
        )
        try:
            resp = requests.get(url, timeout=10)
            resp.raise_for_status()
            buf_img = np.frombuffer(resp.content, dtype=np.uint8)
            cv_img = cv2.imdecode(buf_img, cv2.IMREAD_COLOR)
            if cv_img is None:
                raise ValueError("decode failed")
        except Exception as e:
            self.node.get_logger().error(f"OSM map fetch failed: {e}")
            return

        arr = cv2.cvtColor(cv_img, cv2.COLOR_BGR2RGB)
        self.map_item.setImage(arr)
        self.map_item.setRect(min_x, min_y, max_x - min_x, max_y - min_y)
        self.map_ready = True

    def update_ui(self):
        """Update map background, flight path, range label, and GPR image."""
        if not self.map_ready and len(self.path) > 1:
            self.update_map_background()

        if self.path:
            xs, ys = zip(*self.path)
            self.path_curve.setData(xs, ys)

        if self.latest_range is not None:
            self.range_label.setText(f'Range: {self.latest_range:.2f} m')

        if self.latest_gpr is not None:
            img = self.latest_gpr.T
            self.img_view.setImage(img, autoLevels=True)
            h, w = img.shape
            v = self.img_view.getView()
            v.setRange(xRange=(0, w), yRange=(0, h), padding=0)

    def closeEvent(self, event):
        """Cleanup ROS and threads on window close."""
        self.executor.shutdown()
        self.spin_thread.join(timeout=1.0)
        self.node.destroy_node()
        rclpy.shutdown()
        event.accept()


if __name__ == '__main__':
    app = QApplication(sys.argv)
    gui = TelemetryGUI()
    gui.showMaximized()
    sys.exit(app.exec_())
