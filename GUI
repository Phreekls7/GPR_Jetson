#!/usr/bin/env python3
import sys
import threading
import math
import collections

import rclpy
from rclpy.node import Node
from rclpy.executors import SingleThreadedExecutor
from rclpy.qos import QoSProfile, QoSReliabilityPolicy, QoSDurabilityPolicy

from px4_msgs.msg import VehicleOdometry, DistanceSensor
from sensor_msgs.msg import Image
from cv_bridge import CvBridge

from PyQt5.QtWidgets import (
    QApplication, QMainWindow, QWidget,
    QVBoxLayout, QHBoxLayout, QLabel
)
from PyQt5.QtCore import QTimer, Qt
import pyqtgraph as pg
import numpy as np
import cv2


class TelemetryGUI(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle('Drone Telemetry')

        # ROS2 setup
        rclpy.init()
        self.node = Node('telemetry_gui')
        self.executor = SingleThreadedExecutor()
        self.executor.add_node(self.node)
        threading.Thread(target=self.executor.spin, daemon=True).start()

        # CvBridge
        self.bridge = CvBridge()

        # Flight path
        self.path = []
        self.origin = None

        # GPR & LiDAR state
        self.latest_gpr    = None  # 2D numpy mono8
        self.latest_range  = None  # float
        self.base_range    = None  # float
        self.mount_offset  = 0.40  # m
        self.pix_per_m     = 50    # px/m
        # vertical scale factor for display
        self.vert_scale    = 0.5   # compress to 50% height

        # history of ground distances per column
        self.range_hist = None  # will be deque(maxlen=width)

        # QoS
        qos = QoSProfile(depth=10)
        qos.reliability = QoSReliabilityPolicy.BEST_EFFORT
        qos.durability = QoSDurabilityPolicy.VOLATILE

        # Subscriptions
        self.node.create_subscription(
            Image,
            '/gpr/bscan',
            self.gpr_cb,
            qos)
        self.node.create_subscription(
            DistanceSensor,
            '/fmu/out/distance_sensor',
            self.range_cb,
            qos)
        self.node.create_subscription(
            VehicleOdometry,
            '/fmu/out/vehicle_odometry',
            self.odom_cb,
            qos)

        # Build UI
        central = QWidget()
        self.setCentralWidget(central)
        layout = QVBoxLayout(central)

        # Flight path + range label
        top = QHBoxLayout()
        self.plot = pg.PlotWidget(title='Flight Path')
        self.plot.setBackground('w')
        self.plot.showGrid(True, True)
        self.path_curve = self.plot.plot([], [], pen=pg.mkPen('b', width=2))
        top.addWidget(self.plot, stretch=3)

        self.range_label = QLabel('Range: -- m')
        self.range_label.setAlignment(Qt.AlignCenter)
        top.addWidget(self.range_label, stretch=1)
        layout.addLayout(top, stretch=1)

        # GPR B-scan view
        self.img_view = pg.ImageView()
        for btn in (self.img_view.ui.histogram,
                    self.img_view.ui.roiBtn,
                    self.img_view.ui.menuBtn):
            btn.hide()
        v = self.img_view.getView()
        v.enableAutoRange(False)
        v.setAspectLocked(False)
        layout.addWidget(self.img_view, stretch=1)

        # Timer for updates
        self.timer = QTimer(self)
        self.timer.timeout.connect(self.update_ui)
        self.timer.start(33)

    def gpr_cb(self, msg: Image):
        # Convert ROS Image to numpy
        img = self.bridge.imgmsg_to_cv2(msg, 'mono8')
        h, w = img.shape
        # Init range history deque on first frame
        if self.range_hist is None:
            init = (self.base_range or 0.0) - self.mount_offset
            self.range_hist = collections.deque([init]*w, maxlen=w)
        # Append current ground distance
        if self.latest_range is not None:
            ground = self.latest_range - self.mount_offset
        else:
            ground = (self.base_range or 0.0) - self.mount_offset
        self.range_hist.append(ground)
        self.latest_gpr = img

    def range_cb(self, msg: DistanceSensor):
        self.latest_range = msg.current_distance
        if self.base_range is None:
            self.base_range = msg.current_distance

    def odom_cb(self, msg: VehicleOdometry):
        if msg.pose_frame == VehicleOdometry.POSE_FRAME_FRD:
            x, y, _ = msg.position
        else:
            xn, yn, _ = msg.position
            x, y = yn, xn
        if self.origin is None:
            self.origin = (x, y)
        dx, dy = x - self.origin[0], y - self.origin[1]
        w, xq, yq, zq = msg.q
        yaw = math.atan2(
            2*(w*zq + xq*yq),
            1 - 2*(yq*yq + zq*zq)
        )
        c, s = math.cos(-yaw), math.sin(-yaw)
        fx = dx*c - dy*s
        fy = dx*s + dy*c
        self.path.append((fx, fy))

    def update_ui(self):
        # Flight path
        if self.path:
            xs, ys = zip(*self.path)
            self.path_curve.setData(xs, ys)
        # Range label
        if self.latest_range is not None:
            self.range_label.setText(
                f'Range: {self.latest_range:.2f} m'
            )
        # GPR B-scan with one-way shift & vertical scaling
        if self.latest_gpr is not None and self.range_hist is not None:
            img = self.latest_gpr.copy()
            h, w = img.shape
            shifted = np.zeros_like(img)
            for j in range(w):
                delta = self.range_hist[j] - self.base_range
                off = int(delta * self.pix_per_m)
                # one-way no-wrap shift
                if off > 0:
                    n = min(off, h)
                    shifted[0:h-n, j] = img[n:h, j]
                elif off < 0:
                    n = min(-off, h)
                    shifted[n:h, j] = img[0:h-n, j]
                else:
                    shifted[:, j] = img[:, j]
            # vertical scaling
            new_h = int(h * self.vert_scale)
            resized = cv2.resize(
                shifted,
                (w, new_h),
                interpolation=cv2.INTER_AREA
            )
            disp = resized.T
            self.img_view.setImage(disp, autoLevels=True)
            h2, w2 = disp.shape
            self.img_view.getView().setRange(
                xRange=(0, w2), yRange=(0, h2), padding=0
            )

    def closeEvent(self, event):
        self.executor.shutdown()
        self.node.destroy_node()
        rclpy.shutdown()
        event.accept()


if __name__ == '__main__':
    app = QApplication(sys.argv)
    gui = TelemetryGUI()
    gui.showMaximized()
    sys.exit(app.exec_())
