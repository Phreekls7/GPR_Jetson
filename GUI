import sys
import threading
import math
import rclpy
from rclpy.node import Node
from rclpy.executors import SingleThreadedExecutor

# Messages
from px4_msgs.msg import VehicleOdometry  # REP147-compatible vehicle odometry
from sensor_msgs.msg import Image, Range
from cv_bridge import CvBridge

# QoS for PX4 topics
from rclpy.qos import QoSProfile, QoSReliabilityPolicy, QoSDurabilityPolicy

from PyQt5.QtWidgets import QApplication, QMainWindow, QWidget, QVBoxLayout, QLabel, QHBoxLayout
from PyQt5.QtCore import QTimer, Qt
import pyqtgraph as pg
import numpy as np

class TelemetryGUI(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle('Drone Telemetry')

        # --- ROS2 init, node, and executor in background thread ---
        rclpy.init(args=None)
        self.node = Node('telemetry_gui')
        self.executor = SingleThreadedExecutor()
        self.executor.add_node(self.node)
        self.spin_thread = threading.Thread(target=self.executor.spin, daemon=True)
        self.spin_thread.start()

        # --- Subscribers (with matching QoS) ---
        self.bridge = CvBridge()
        self.node.create_subscription(Image, '/gpr/bscan', self.gpr_cb, qos_profile=10)
        self.node.create_subscription(Range, '/range', self.range_cb, qos_profile=10)
        odom_qos = QoSProfile(depth=10)
        odom_qos.reliability = QoSReliabilityPolicy.BEST_EFFORT
        odom_qos.durability = QoSDurabilityPolicy.VOLATILE
        self.node.create_subscription(VehicleOdometry, '/fmu/out/vehicle_odometry', self.odom_cb, qos_profile=odom_qos)

        # --- Data containers ---
        self.path = []           # list of (x, y)
        self.origin = None       # for centering path
        self.latest_gpr = None   # numpy array for GPR image
        self.latest_range = None # float for range

        # --- Build UI ---
        central = QWidget()
        self.setCentralWidget(central)
        layout = QVBoxLayout(central)

        # Top layout: flight path + range display
        top = QHBoxLayout()
        self.plot_widget = pg.PlotWidget(title="Flight Path")
        self.plot_widget.setAspectLocked(True)
        self.plot_widget.enableAutoRange()
        self.path_curve = self.plot_widget.plot([], [], pen=pg.mkPen(width=2))
        top.addWidget(self.plot_widget, stretch=3)

        self.range_label = QLabel("Range: -- m")
        self.range_label.setAlignment(Qt.AlignCenter)
        self.range_label.setFixedWidth(150)
        top.addWidget(self.range_label, stretch=1)
        layout.addLayout(top, stretch=1)

        # Bottom: GPR B-scan image
        self.img_view = pg.ImageView(view=pg.PlotItem())
        self.img_view.ui.histogram.hide()
        self.img_view.ui.roiBtn.hide()
        self.img_view.ui.menuBtn.hide()
        layout.addWidget(self.img_view, stretch=2)

        # --- Timer for UI updates ---
        self.ui_timer = QTimer()
        self.ui_timer.timeout.connect(self.update_ui)
        self.ui_timer.start(30)  # ms (~33 Hz)

    def gpr_cb(self, msg: Image):
        """Handle incoming GPR B-scan Image."""
        self.latest_gpr = self.bridge.imgmsg_to_cv2(msg, desired_encoding='mono8')

    def odom_cb(self, msg: VehicleOdometry):
        """
        Handle VehicleOdometry.
        Use FRD if available, else convert NED→ENU. Rotate using yaw so heading aligns loops.
        """
        # Select frame
        if msg.pose_frame == VehicleOdometry.POSE_FRAME_FRD:
            x, y, _ = msg.position
        else:
            x_ned, y_ned, _ = msg.position
            x = y_ned
            y = x_ned

        # Initialize origin on first callback
        if self.origin is None:
            self.origin = (x, y)
        # Compute relative position
        x_rel = x - self.origin[0]
        y_rel = y - self.origin[1]

        # Compute yaw from quaternion (w,x,y,z)
        w, xq, yq, zq = msg.q
        yaw = math.atan2(2*(w*zq + xq*yq), 1 - 2*(yq*yq + zq*zq))

        # Rotate relative XY by -yaw to align heading
        cos_y = math.cos(-yaw)
        sin_y = math.sin(-yaw)
        x_rot = x_rel * cos_y - y_rel * sin_y
        y_rot = x_rel * sin_y + y_rel * cos_y

        # Append rotated point
        self.path.append((x_rot, y_rot))
        self.node.get_logger().debug(
            f"[GUI] odom_cb → x_rel={x_rel:.2f}, y_rel={y_rel:.2f}, yaw={math.degrees(yaw):.1f}°"
        )

    def range_cb(self, msg: Range):
        """Handle incoming Range."""
        self.latest_range = msg.range

    def update_ui(self):
        """Update all UI elements: path, range label, GPR image."""
        # Flight path
        if self.path:
            xs, ys = zip(*self.path)
            self.path_curve.setData(xs, ys)
        # Range
        if self.latest_range is not None:
            self.range_label.setText(f"Range: {self.latest_range:.2f} m")
        # GPR image
        if self.latest_gpr is not None:
            self.img_view.setImage(self.latest_gpr.T, autoLevels=True)

    def closeEvent(self, event):
        """Clean up ROS and threads on window close."""
        self.executor.shutdown()
        self.spin_thread.join(timeout=1.0)
        self.node.destroy_node()
        rclpy.shutdown()
        event.accept()

if __name__ == '__main__':
    app = QApplication(sys.argv)
    gui = TelemetryGUI()
    gui.showMaximized()
    sys.exit(app.exec_())
